# 野炊教学数据管理系统 - 数据库结构设计方案

## 📋 方案概述

### 当前问题分析

1. **存储方式问题**
   - 使用文件系统（JSON文件）存储，查询效率低
   - 数据冗余严重（每个JSON都包含完整的teamInfo）
   - 没有索引，排序和筛选性能差
   - 数据分散在多个文件中，管理困难

2. **扩展性问题**
   - 数据结构变更需要手动迁移所有文件
   - 没有版本管理机制
   - 新增字段需要修改多处代码
   - 向后兼容性差

3. **维护性问题**
   - 数据备份和恢复困难
   - 无法进行复杂查询和统计
   - 数据一致性难以保证

### 设计目标

1. **灵活性**：能够快速适应App数据结构的变更
2. **可扩展性**：支持新增字段和数据类型，无需大规模重构
3. **性能**：支持高效查询、排序和统计
4. **可维护性**：易于备份、迁移和版本管理
5. **向后兼容**：支持平滑升级，不丢失历史数据

---

## 🗄️ 数据库选型

### 推荐方案：SQLite

**选择理由：**
- ✅ **轻量级**：单文件数据库，无需独立服务器，适合单机部署
- ✅ **零配置**：开箱即用，无需安装和配置
- ✅ **性能优秀**：支持索引、事务，查询速度快
- ✅ **跨平台**：Python原生支持，易于部署
- ✅ **可靠性高**：ACID事务支持，数据安全
- ✅ **易于备份**：单文件，直接复制即可

**替代方案（如未来需要）：**
- PostgreSQL（如果需要多用户并发访问）
- MySQL（如果需要更复杂的查询需求）

---

## 📊 数据库表结构设计

### 核心设计理念

1. **关系型设计**：避免数据冗余，使用外键关联
2. **版本管理**：每个表都有`schema_version`字段，支持版本迁移
3. **灵活扩展**：使用JSON字段存储动态数据，支持未来扩展
4. **时间戳追踪**：所有表都有`created_at`和`updated_at`，便于审计

### 表结构详细设计

#### 1. `teams` - 团队信息表（核心表）

```sql
CREATE TABLE teams (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id TEXT UNIQUE NOT NULL,  -- 唯一标识：school_grade_className_stoveNumber
    school TEXT NOT NULL,
    grade TEXT NOT NULL,
    class_name TEXT NOT NULL,
    stove_number TEXT NOT NULL,
    member_count INTEGER NOT NULL DEFAULT 0,
    member_names TEXT NOT NULL,  -- 逗号分隔的成员姓名
    created_at INTEGER NOT NULL,  -- 时间戳（毫秒）
    updated_at INTEGER NOT NULL,
    schema_version INTEGER NOT NULL DEFAULT 1,  -- 数据结构版本
    extra_data TEXT,  -- JSON字段，存储未来可能新增的字段
    UNIQUE(school, grade, class_name, stove_number)
);

CREATE INDEX idx_teams_team_id ON teams(team_id);
CREATE INDEX idx_teams_school ON teams(school);
CREATE INDEX idx_teams_stove_number ON teams(stove_number);
```

**设计说明：**
- `team_id`作为唯一标识，便于快速查找
- `extra_data` JSON字段用于存储未来可能新增的字段（如：班级编号、指导教师等）
- 索引优化常用查询字段

---

#### 2. `team_divisions` - 团队分工表

```sql
CREATE TABLE team_divisions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id TEXT NOT NULL,
    group_leader TEXT,  -- 项目组长
    group_cooking TEXT,  -- 烹饪组
    group_soup_rice TEXT,  -- 汤饭组
    group_fire TEXT,  -- 生火组
    group_health TEXT,  -- 卫生组
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    schema_version INTEGER NOT NULL DEFAULT 1,
    extra_data TEXT,  -- JSON字段，存储未来可能新增的分工类型
    FOREIGN KEY (team_id) REFERENCES teams(team_id) ON DELETE CASCADE,
    UNIQUE(team_id)  -- 每个团队只有一条分工记录
);

CREATE INDEX idx_team_divisions_team_id ON team_divisions(team_id);
```

**设计说明：**
- 与`teams`表一对一关系
- 如果未来需要支持分工历史记录，可以移除`UNIQUE`约束

---

#### 3. `process_records` - 过程记录表

```sql
CREATE TABLE process_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id TEXT NOT NULL,
    start_time INTEGER NOT NULL,
    end_time INTEGER,
    current_stage TEXT,  -- 当前阶段名称
    overall_notes TEXT,  -- 总体备注
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    schema_version INTEGER NOT NULL DEFAULT 1,
    extra_data TEXT,  -- JSON字段，存储未来可能新增的字段
    FOREIGN KEY (team_id) REFERENCES teams(team_id) ON DELETE CASCADE,
    UNIQUE(team_id)  -- 每个团队只有一条过程记录
);

CREATE INDEX idx_process_records_team_id ON process_records(team_id);
CREATE INDEX idx_process_records_start_time ON process_records(start_time);
```

**设计说明：**
- 与`teams`表一对一关系
- 学生可能会多次修改和提交过程记录，但只保留最后一次提交的数据
- 在应用层使用`UPDATE`操作更新记录，而不是`INSERT`新记录
- `updated_at`字段记录最后一次更新时间
- `current_stage`字段表示当前进行到哪个阶段，判断逻辑：

  - **方式3（使用这个）**：由App在学生进入新阶段时主动更新`current_stage`字段
  - 如果所有阶段都已完成（`is_completed = 1`），`current_stage`可以设置为`COMPLETED`或`NULL`

---

#### 4. `stage_records` - 阶段记录表

```sql
CREATE TABLE stage_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    process_record_id INTEGER NOT NULL,
    stage_name TEXT NOT NULL,  -- PREPARATION, FIRE_MAKING, COOKING_RICE等
    start_time INTEGER NOT NULL,
    end_time INTEGER,
    self_rating INTEGER DEFAULT 0,  -- 1-5星评分
    notes TEXT,  -- 做得好的地方
    problem_notes TEXT,  -- 需要改进的地方
    is_completed INTEGER NOT NULL DEFAULT 0,  -- 0=未完成, 1=已完成
    selected_tags TEXT,  -- JSON数组，存储选择的标签
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    schema_version INTEGER NOT NULL DEFAULT 1,
    extra_data TEXT,  -- JSON字段，存储未来可能新增的字段
    FOREIGN KEY (process_record_id) REFERENCES process_records(id) ON DELETE CASCADE,
    UNIQUE(process_record_id, stage_name)  -- 每个过程记录的每个阶段只有一条记录
);

CREATE INDEX idx_stage_records_process_id ON stage_records(process_record_id);
CREATE INDEX idx_stage_records_stage_name ON stage_records(stage_name);
CREATE INDEX idx_stage_records_completed ON stage_records(is_completed);
```

**设计说明：**
- 与`process_records`表一对多关系
- `selected_tags`使用JSON数组存储，便于扩展
- 支持按阶段查询和统计

**`stage_name`字段说明：**
`stage_name`存储的是App中定义的阶段枚举名称，对应App中的`CookingStage`枚举。各阶段含义如下：

| stage_name | App显示名称 | 图标 | 说明 | 顺序 |
|------------|------------|------|------|------|
| `PREPARATION` | 准备阶段 | 📋 | 准备食材和工具 | 1 |
| `FIRE_MAKING` | 生火 | 🔥 | 搭建灶台并点燃柴火 | 2 |
| `COOKING_RICE` | 煮饭 | 🍚 | 淘米煮饭 | 3 |
| `COOKING_DISHES` | 炒菜 | 🥘 | 清洗切配并炒制菜品 | 4 |
| `SHOWCASE` | 成果展示 | 🎉 | 展示成果和分享（需要小组合照、菜品合照和语言表述视频） | 5 |
| `CLEANING` | 卫生清洁 | 🧹 | 清理和整理 | 6 |
| `COMPLETED` | 整体表现 | ✅ | 用餐和收拾 | 7 |

**注意：**
- 阶段名称必须与App中的`CookingStage`枚举值完全一致（区分大小写）
- 每个过程记录（`process_record_id`）的每个阶段（`stage_name`）只能有一条记录
- 阶段按`order`字段顺序进行，但学生可以自由切换阶段

**显示顺序要求（重要）：**
虽然学生可能会来回修改数据，但在后端页面查看时，**阶段显示顺序必须始终保持以下固定顺序**：

1. PREPARATION（准备阶段）
2. FIRE_MAKING（生火）
3. COOKING_RICE（煮饭）
4. COOKING_DISHES（炒菜）
5. SHOWCASE（成果展示）
6. CLEANING（卫生清洁）
7. COMPLETED（整体表现）

**实现方式：**
在查询和显示阶段记录时，必须按照上述顺序排序，不能按照数据库中的`created_at`、`updated_at`或`start_time`排序。建议在后端代码中定义阶段顺序映射表，使用`CASE WHEN`或程序逻辑来保证显示顺序。

**SQL查询示例：**
```sql
SELECT * FROM stage_records 
WHERE process_record_id = ?
ORDER BY CASE stage_name
    WHEN 'PREPARATION' THEN 1
    WHEN 'FIRE_MAKING' THEN 2
    WHEN 'COOKING_RICE' THEN 3
    WHEN 'COOKING_DISHES' THEN 4
    WHEN 'SHOWCASE' THEN 5
    WHEN 'CLEANING' THEN 6
    WHEN 'COMPLETED' THEN 7
    ELSE 999
END;
```

---

#### 5. `media_items` - 媒体文件表

```sql
CREATE TABLE media_items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    stage_record_id INTEGER,  -- 关联阶段记录（可为NULL，用于课后总结的照片）
    summary_question INTEGER,  -- 1, 2, 3 表示课后总结的问题编号（可为NULL）
    file_path TEXT NOT NULL,
    file_type TEXT NOT NULL,  -- PHOTO 或 VIDEO
    file_size INTEGER,  -- 文件大小（字节）
    timestamp INTEGER NOT NULL,
    created_at INTEGER NOT NULL,
    schema_version INTEGER NOT NULL DEFAULT 1,
    extra_data TEXT,  -- JSON字段，存储未来可能新增的字段（如：缩略图路径、时长等）
    FOREIGN KEY (stage_record_id) REFERENCES stage_records(id) ON DELETE CASCADE
);

CREATE INDEX idx_media_items_stage_id ON media_items(stage_record_id);
CREATE INDEX idx_media_items_file_path ON media_items(file_path);
CREATE INDEX idx_media_items_type ON media_items(file_type);
```

**设计说明：**
- 支持两种关联方式：
  - 关联到阶段记录（过程记录中的照片/视频）
  - 关联到课后总结（通过`summary_question`字段）
- 统一管理所有媒体文件，便于查询和清理

---

#### 6. `summary_data` - 课后总结表

```sql
CREATE TABLE summary_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id TEXT NOT NULL,
    answer1 TEXT,
    answer2 TEXT,
    answer3 TEXT,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    schema_version INTEGER NOT NULL DEFAULT 1,
    extra_data TEXT,  -- JSON字段，存储未来可能新增的问题和答案
    FOREIGN KEY (team_id) REFERENCES teams(team_id) ON DELETE CASCADE,
    UNIQUE(team_id)  -- 每个团队只有一条总结记录
);

CREATE INDEX idx_summary_data_team_id ON summary_data(team_id);
```

**设计说明：**
- 与`teams`表一对一关系
- 照片通过`media_items`表的`summary_question`字段关联
- `extra_data`可以存储未来可能新增的问题（answer4, answer5等）

---

#### 7. `teacher_evaluations` - 教师评价表

```sql
CREATE TABLE teacher_evaluations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id TEXT NOT NULL,
    stage_name TEXT,  -- 评价的阶段（可为NULL表示总体评价）
    rating INTEGER NOT NULL DEFAULT 0,  -- 1-5星评分
    comment TEXT,  -- 评价内容
    strengths TEXT,  -- 优点
    improvements TEXT,  -- 需要改进的地方
    timestamp INTEGER NOT NULL,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    schema_version INTEGER NOT NULL DEFAULT 1,
    extra_data TEXT,  -- JSON字段，存储未来可能新增的字段
    FOREIGN KEY (team_id) REFERENCES teams(team_id) ON DELETE CASCADE,
    UNIQUE(team_id)  -- 每个团队只有一条评价记录
);

CREATE INDEX idx_teacher_evaluations_team_id ON teacher_evaluations(team_id);
CREATE INDEX idx_teacher_evaluations_stage ON teacher_evaluations(stage_name);
CREATE INDEX idx_teacher_evaluations_timestamp ON teacher_evaluations(timestamp);
```

**设计说明：**
- 与`teams`表一对一关系
- 支持按阶段评价和总体评价（通过`stage_name`字段区分，可为NULL表示总体评价）
- 教师可能会多次修改和提交评价，但只保留最后一次提交的数据
- 在应用层使用`UPDATE`操作更新记录，而不是`INSERT`新记录
- `updated_at`字段记录最后一次更新时间

---

#### 8. `data_versions` - 数据版本管理表

```sql
CREATE TABLE data_versions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    table_name TEXT NOT NULL,
    schema_version INTEGER NOT NULL,
    migration_script TEXT,  -- 迁移脚本（可选）
    applied_at INTEGER NOT NULL,
    description TEXT
);

CREATE INDEX idx_data_versions_table ON data_versions(table_name);
```

**设计说明：**
- 记录每个表的版本历史
- 支持数据迁移和回滚

---

## 🔄 数据迁移方案

### 版本管理机制

1. **Schema Version字段**
   - 每个表都有`schema_version`字段
   - 初始版本为1，每次结构变更递增

2. **迁移脚本系统**
   - 创建`migrations/`目录存储迁移脚本
   - 命名规则：`V{version}__{description}.sql`
   - 例如：`V2__add_extra_data_to_teams.sql`

3. **自动迁移流程**
   ```python
   # 伪代码示例
   def migrate_database():
       current_version = get_current_schema_version('teams')
       target_version = 2
       
       if current_version < target_version:
           # 执行迁移脚本
           execute_migration('V2__add_extra_data_to_teams.sql')
           update_schema_version('teams', 2)
   ```

### 向后兼容策略

1. **字段扩展**
   - 新增字段使用`extra_data` JSON字段存储
   - 或添加新列，设置默认值，保证旧数据可用

2. **字段废弃**
   - 不直接删除字段，标记为`deprecated`
   - 保留字段用于读取旧数据，新数据不使用

3. **数据转换**
   - 提供数据转换工具，将旧格式转换为新格式
   - 支持批量转换历史数据

---

## 📦 数据访问层设计

### ORM方案：SQLAlchemy

**选择理由：**
- ✅ Python最流行的ORM框架
- ✅ 支持SQLite、MySQL、PostgreSQL等多种数据库
- ✅ 自动生成SQL，减少SQL注入风险
- ✅ 支持数据库迁移工具（Alembic）
- ✅ 代码可读性强，易于维护

### 模型定义示例

```python
from sqlalchemy import Column, Integer, String, Text, ForeignKey, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
import json

Base = declarative_base()

class Team(Base):
    __tablename__ = 'teams'
    
    id = Column(Integer, primary_key=True)
    team_id = Column(String, unique=True, nullable=False)
    school = Column(String, nullable=False)
    grade = Column(String, nullable=False)
    class_name = Column(String, nullable=False)
    stove_number = Column(String, nullable=False)
    member_count = Column(Integer, default=0)
    member_names = Column(Text, nullable=False)
    created_at = Column(Integer, nullable=False)
    updated_at = Column(Integer, nullable=False)
    schema_version = Column(Integer, default=1)
    extra_data = Column(Text)  # JSON字符串
    
    # 关系
    division = relationship("TeamDivision", back_populates="team", uselist=False)
    process_record = relationship("ProcessRecord", back_populates="team", uselist=False)
    summary = relationship("SummaryData", back_populates="team", uselist=False)
    teacher_evaluation = relationship("TeacherEvaluation", back_populates="team", uselist=False)
    
    def get_extra_data(self):
        """解析extra_data JSON"""
        if self.extra_data:
            return json.loads(self.extra_data)
        return {}
    
    def set_extra_data(self, data):
        """设置extra_data JSON"""
        self.extra_data = json.dumps(data, ensure_ascii=False)
```

---

## 🚀 实施步骤

### 阶段1：数据库初始化（1-2天）

1. 创建数据库文件（SQLite）
2. 执行建表SQL脚本
3. 创建索引
4. 编写基础ORM模型

### 阶段2：数据迁移工具（2-3天）

1. 编写JSON文件读取工具
2. 编写数据转换脚本
3. 批量导入现有数据
4. 数据验证和修复

### 阶段3：API重构（3-4天）

1. 重构`storage.py`，使用数据库替代文件系统
2. 更新所有API接口
3. 保持API接口不变，确保前端无需修改
4. 添加数据版本管理

### 阶段4：测试和优化（2-3天）

1. 单元测试
2. 性能测试和优化
3. 数据备份和恢复测试
4. 文档编写

---

## 💡 扩展性设计

### 未来可能的需求

1. **多活动支持**
   - 添加`activities`表，支持多次野炊活动
   - `teams`表关联到`activities`

2. **用户权限管理**
   - 添加`users`和`roles`表
   - 支持教师、管理员等角色

3. **数据统计和分析**
   - 创建视图（Views）用于常用统计查询
   - 支持导出Excel、PDF等格式

4. **实时通知**
   - 添加`notifications`表
   - 支持WebSocket推送

### 扩展字段使用示例

```python
# 在extra_data中存储新字段
team = Team(...)
team.set_extra_data({
    'instructor': '张老师',  # 新增：指导教师
    'location': '野炊基地A区',  # 新增：活动地点
    'weather': '晴天'  # 新增：天气情况
})

# 读取扩展字段
extra = team.get_extra_data()
instructor = extra.get('instructor', '')
```

---

## ⚠️ 注意事项

1. **数据备份**
   - SQLite是单文件，定期备份`*.db`文件
   - 建议每天自动备份

2. **并发访问**
   - SQLite支持多读单写
   - 如果未来需要高并发，考虑升级到PostgreSQL

3. **性能优化**
   - 合理使用索引
   - 避免全表扫描
   - 定期执行`VACUUM`优化数据库

4. **数据迁移**
   - 迁移前务必备份
   - 在测试环境先验证
   - 提供回滚方案

---

## 📝 总结

### 优势

1. ✅ **灵活性**：JSON字段支持快速扩展，无需修改表结构
2. ✅ **性能**：索引优化，查询速度快
3. ✅ **可维护性**：关系型设计，数据一致性好
4. ✅ **可扩展性**：支持未来功能扩展
5. ✅ **向后兼容**：版本管理机制，平滑升级

### 实施建议

1. **先实施核心表**：`teams`、`team_divisions`、`process_records`
2. **逐步迁移数据**：先迁移新数据，旧数据保留兼容
3. **保持API不变**：确保前端无需修改
4. **充分测试**：在测试环境验证后再上线

---

## ❓ 待确认问题

1. **是否需要支持多次野炊活动？**（当前设计支持，但需要确认业务需求）
2. **媒体文件存储方式？**（当前是文件系统，是否需要改为数据库BLOB？）
3. **数据保留策略？**（是否需要定期清理旧数据？）
4. **是否需要数据导出功能？**（Excel、PDF等格式）

---

**请确认以上方案是否符合您的需求，确认后我将开始实施重构。**


